#' Split outcome column 
#'
#' This function takes the outcome column from the results generated by mr() and splits it into separate columns for 'outcome name' and 'id'
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame

split_outcome <- function(mr_res)
{
	Pos<-grep("\\|\\|",mr_res$outcome) #the "||"" indicates that the outcome column was derived from summary data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
	Outcome<-as.character(mr_res$outcome[Pos])
	Vars<-strsplit(Outcome,split= "\\|\\|")
	Vars<-unlist(Vars)
	Vars<-trim(Vars)
	Trait<-Vars[seq(1,length(Vars),by=2)]
	id<-Vars[seq(2,length(Vars),by=2)]
	mr_res$outcome<-as.character(mr_res$outcome)
	mr_res$outcome[Pos]<-Trait
	return(mr_res)
}

#' Split exposure column 
#'
#' This function takes the exposure column from the results generated by mr() and splits it into separate columns for 'exposure name' and 'id'
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame
split_exposure <- function(mr_res)
{
	Pos<-grep("\\|\\|",mr_res$exposure) #the "||"" indicates that the outcome column was derived from summary data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
	Exposure<-as.character(mr_res$exposure[Pos])
	Vars<-strsplit(as.character(Exposure),split= "\\|\\|")
	Vars<-unlist(Vars)
	Vars<-trim(Vars)
	Trait<-Vars[seq(1,length(Vars),by=2)]
	mr_res$exposure<-as.character(mr_res$exposure)
	mr_res$exposure[Pos]<-Trait
	return(mr_res)
}


#' Generate odds ratios 
#'
#' This function takes b and se from mr() and generates odds ratios and 95 percent confidence intervals
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame		
generate_odds_ratios <- function(mr_res) 
{
	mr_res$lo_ci <- mr_res$b - 1.96 * mr_res$se
	mr_res$up_ci <- mr_res$b + 1.96 * mr_res$se
	mr_res$or <- exp(mr_res$b)
	mr_res$or_lci95 <- exp(mr_res$lo_ci)
	mr_res$or_uci95 <- exp(mr_res$up_ci)
	return(mr_res)
}

#' Subset MR-results on method
#'
#' This function takes MR results from mr() and restricts to a single method per exposure x disease combination 
#'
#' @param mr_res Results from mr()
#' @param single_snp_method Which of the single SNP methosd to use when only 1 SNP was used to estimate the causal effect? Default="Wald ratio"
#' @param multi_snp_method Which of the multi-SNP methods to use when there was more than 1 SNPs used to estimate the causal effect? Default="Inverse variance weighted"
#'
#' @export
#' @return data frame.
subset_on_method <- function(mr_res, single_snp_method="Wald ratio", multi_snp_method="Inverse variance weighted")
{
	dat <- subset(mr_res, (nsnp==1 & method==single_snp_method) | (nsnp > 1 & method == multi_snp_method))
	return(dat)

}

#' Combine all mr results
#'
#' This function combines results of mr(), mr_heterogeneity(), mr_pleiotropy_test() and mr_singlesnp() into a single data frame. It also merges the results with outcome study level characteristics in available_outcomes(). If desired it also exponentiates results (e.g. if the user wants log odds ratio converted into odds ratios with 95 percent confidence intervals). The exposure and outcome columns from the output from mr() contain both the trait names and trait ids. The combine_all_mrresults() function splits these into separate columns by default. 

#' @param res Results from mr()
#' @param het Results from mr_heterogeneity()
#' @param pleiotropy Results from mr_pleiotropy_test()
#' @param sin Results from mr_singlesnp()
#' @param ao_slc Logical; if set to TRUE then outcome study level characteristics are retrieved from available_outcomes(). Default is TRUE. 
#' @param Exp Logical; if set to TRUE results are exponentiated. Useful if user wants log odds ratios expressed as odds ratios. Default is FALSE. 
#' @param split.exposure Logical; if set to TRUE the exposure column is split into separate columns for the exposure name and exposure ID. Default is FALSE. 
#' @param split.outcome Logical; if set to TRUE the outcome column is split into separate columns for the outcome name and outcome ID. Default is FALSE.  
#' 
#' @export
#' @return data frame


# library(TwoSampleMR)
# library(MRInstruments)

# exp_dat <- extract_instruments(outcomes=c(2,300))

# chd_out_dat <- extract_outcome_data(
#     snps = exp_dat$SNP,
#     outcomes = c(6,7,8,9)
# )

# dat <- harmonise_data(
#     exposure_dat = exp_dat, 
#     outcome_dat = chd_out_dat
# )

# dat<-power.prune(dat,method.size=F)


# Res<-mr(dat)
# Het<-mr_heterogeneity(dat)
# Plt<-mr_pleiotropy_test(dat)
# Sin<-mr_singlesnp(dat)

# All.res<-combine_all_mrresults(Res=Res,Het=Het,Plt=Plt,Sin=Sin)
# All.res<-split_exposure(All.res)
# All.res<-split_outcome(All.res)

combine_all_mrresults <- function(res,het,plt,sin,ao_slc=T,Exp=F,split.exposure=F,split.outcome=F)
{
	requireNamespace("plyr", quietly=TRUE)

	het<-het[,c("id.exposure","id.outcome","method","Q","Q_df","Q_pval")]

	# Convert all factors to character
	# lapply(names(Res), FUN=function(x) class(Res[,x]))
	Pos<-which(unlist(lapply(names(res), FUN=function(x) class(res[,x])))=="factor")
	for(i in 1:length(Pos)){
		res[,Pos[i]]<-as.character(res[,Pos[i]])
	}

	# lapply(names(Het), FUN=function(x) class(Het[,x]))
	Pos<-which(unlist(lapply(names(het), FUN=function(x) class(het[,x])))=="factor")
	for(i in 1:length(Pos)){
		het[,Pos[i]]<-as.character(het[,Pos[i]])
	}

	# lapply(names(Sin), FUN=function(x) class(Sin[,x]))
	Pos<-which(unlist(lapply(names(sin), FUN=function(x) class(sin[,x])))=="factor")
	for(i in 1:length(Pos)){
		sin[,Pos[i]]<-as.character(sin[,Pos[i]])
	}
	sin<-sin[grep("[:0-9:]",sin$SNP),]
	sin$method<-"Wald ratio"
	names(sin)[names(sin)=="p"]<-"pval"

	# Res<-Res[Res$method %in% c("MR Egger","Weighted median","Inverse variance weighted"),]

	#method is also the name of an argument in the method function. this prevents all.x argument from working. rename method column
	names(res)[names(res)=="method"]<-"Method"
	names(het)[names(het)=="method"]<-"Method"
	names(sin)[names(sin)=="method"]<-"Method"

	res<-merge(res,het,by=c("id.outcome","id.exposure","Method"),all.x=T)
	res<-plyr::rbind.fill(res,sin[,c("exposure","outcome","id.exposure","id.outcome","SNP","b","se","pval","Method")])

	if(ao_slc)
	{
		ao<-available_outcomes()
		names(ao)[names(ao)=="nsnp" ]<-"nsnps.outcome.array"
		res<-merge(res,ao[,!names(ao) %in% c("unit","priority","sd","path","note","filename","access","mr")],by.x="id.outcome",by.y="id")
	}

	res$nsnp[is.na(res$nsnp)]<-1

	for(i in unique(res$id.outcome))
	{
		Methods<-unique(res$Method[res$id.outcome==i])
		Methods<-Methods[Methods!="Wald ratio"]
		for(j in unique(Methods))
		{
			res$SNP[res$id.outcome == i & res$Method==j]<-paste(res$SNP[res$id.outcome == i & res$Method=="Wald ratio"],collapse="; ")
		}
	}

	if(Exp){
		res$or<-exp(res$b)
		res$or_lci95<-exp(res$b-res$se*1.96)
		res$or_uci95<-exp(res$b+res$se*1.96)
	}

	# add intercept test from MR Egger
	plt<-plt[,c("id.outcome","id.exposure","egger_intercept","se","pval")]
	plt$Method<-"MR Egger"
	names(plt)[names(plt)=="egger_intercept"]<-"intercept"
	names(plt)[names(plt)=="se"]<-"intercept_se"
	names(plt)[names(plt)=="pval"]<-"intercept_pval"

	res<-merge(res,plt,by=c("id.outcome","id.exposure","Method"),all.x=T)

	if(split.exposure){
		res<-split_exposure(res)
	}
	
	if(split.outcome){
		res<-split_outcome(res)
	}

	Cols<-c("Method","outcome","exposure","nsnp","b","se","pval","intercept","intercept_se","intercept_pval","Q","Q_df","Q_pval","consortium","ncase","ncontrol","pmid","population")

	res<-res[,c(names(res)[names(res) %in% Cols],names(res)[which(!names(res) %in% Cols)])]

	# names(ResSNP)<-tolower(names(ResSNP))
	return(res)
}

#' Power prune 
#'
#' When there are duplicate summary sets for a particular exposure-outcome combination, this function keeps the exposure-outcome summary set with the highest expected statistical power. This can be done by dropping the duplicate summary sets with the smaller outcome sample sizes. Alternatively, the pruning procedure can take into account both instrument strength and outcome sample size. The latter is useful, for example, when there is considerable variation in SNP coverage between duplicate outcome GWAS (e.g. because some studies have used targeted or fine mapping arrays). If there are a large number of SNPs available to instrument an exposure, the outcome GWAS with the better SNP coverage may provide better power than the outcome GWAS with the larger sample size. However, this latter procedure should only be implemented if the SNP-outcome effects are log odds ratios and the SNP-exposure effects are in standard deviation units. 

#'
#' @param dat Results from harmonise_data() 
#' @param method.size  Should the duplicate summary sets be pruned on the basis of sample size? Default set to TRUE. If available, the method uses the number of cases to represent sample size. If the number of cases is missing then the total sample size is used. If method.size is set to FALSE then duplicates are dropped on the basis of expected statistical power, taking into account instrument strength and sample size, and assumes that the SNP-outcome effects are log odds ratios and that the SNP-exposure effects are in standard deviation units. 
#' 
#' @export
#' @return data frame

# library(TwoSampleMR)
# library(MRInstruments)

# exp_dat <- extract_instruments(outcomes=c(2,300))

# chd_out_dat <- extract_outcome_data(
#     snps = exp_dat$SNP,
#     outcomes = c(6,7,8,9)
# )

# dat <- harmonise_data(
#     exposure_dat = exp_dat, 
#     outcome_dat = chd_out_dat
# )

# dat2<-power.prune(dat,drop.duplicates=T)

power.prune <- function(dat,method.size=T)
{

	# dat[,c("eaf.exposure","beta.exposure","se.exposure","samplesize.outcome","ncase.outcome","ncontrol.outcome")]
	drop.duplicates=T

	if(method.size==T){
		dat$ncase.outcome[is.na(dat$ncase.outcome)]<-dat$samplesize.outcome[is.na(dat$ncase.outcome)]
		dat<-dat[order(dat$ncase.outcome,decreasing=T),]
		id.expout<-paste(dat$exposure,dat$outcome)
		id.keep<-id.expout[!duplicated(paste(dat$exposure,dat$originalname.outcome))]
		# dat$power<-as.numeric(as.factor(-dat$ncase.outcome))
		if(drop.duplicates==T){
			dat<-dat[id.expout %in% id.keep,]
		}
	}

	if(method.size==F){
		p<-dat$eaf.exposure #effect allele frequency
		b<-abs(dat$beta.exposure) # effect of SNP on risk factor
		se<-dat$se.exposure
		# n<-dat$samplesize.exposure
		n.cas<-dat$ncase.outcome
		n.con<-dat$ncontrol.outcome
		b1=log(1.05) # assumed log odds ratio
		sig<-0.05 #alpha

		var<-1 # variance of risk factor assumed to be 1 
		# if(!vareq1){ #if variance not 1 then estimate standardized beta using this syntax
		# 	z = b/se
		# 	b = z/sqrt(2*p*(1-p)*(n+z^2))
			
		# }

		r2<-2*b^2*p*(1-p)/var

		#Once the r2 is calculated you then sum the r2 statistics across all the SNPs in the instrument. 
		#This assumes each SNP is independent. 
		#calculate the F statistic for the instrument:
		id<-paste(dat$exposure,dat$outcome)
		power<-NULL
		iv.se<-NULL
		ID<-NULL
		for(i in 1:length(unique(id))){
			print(unique(id)[i])
			pos<-which(id==unique(id)[i])
			# print(pos)
			k<-length(p[pos]) #number of SNPs in the instrument / associated with the risk factor
			# n<-min(n) #sample size of the exposure/risk factor GWAS
			r2sum<-sum(r2[pos]) # sum of the r-squares for each SNP in the instrument
			# F<-r2sum*(n-1-k)/((1-r2sum*k )
			n<-unique(n.con[pos]+n.cas[pos])
			ratio<-unique(n.cas[pos]/n.con[pos])
			iv.se[[i]]<-1/sqrt(unique(n.cas[pos])*unique(n.con[pos])*r2sum) #standard error of the IV should be proportional to this
			power[[i]]<-pnorm(sqrt(n*r2sum*(ratio/(1+ratio))*(1/(1+ratio)))*b1-qnorm(1-sig/2))
			ID[[i]]<-unique(id)[i]
		}
		power.tab<-data.frame(as.matrix(cbind(ID,power)),stringsAsFactors=F)
		dat$id.expout<-paste(dat$exposure,dat$outcome)
		dat<-merge(dat,power.tab,by.x="id.expout",by.y="ID")
		dat<-dat[order(dat$power,decreasing=T),]
		# unique(dat[,c("originalname.outcome","Power")])
		if(drop.duplicates==T){
			id.keep<-dat$id.expout[!duplicated(paste(dat$exposure,dat$originalname.outcome))]
			dat<-dat[dat$id.expout %in% id.keep,]

		}
	}
	return(dat)
}

#' Size prune 
#'
#' Whens there are duplicate summary sets for a particular exposure-outcome combination, this function drops the duplicates with the smaller total sample size (for binary outcomes, the number of cases is used instead of total sample size).  
#'
#' @param dat Results from harmonise_data() 
#' 
#' @export
#' @return data frame

size.prune <- function(dat)
{
	dat$ncase[is.na(dat$ncase)]<-dat$samplesize[is.na(dat$ncase)]
	dat<-dat[order(dat$ncase,decreasing=T),]
	id.expout<-paste(dat$exposure,dat$outcome)
	id.keep<-id.expout[!duplicated(paste(dat$exposure,dat$originalname.outcome))]
	dat<-dat[id.expout %in% id.keep,]
}





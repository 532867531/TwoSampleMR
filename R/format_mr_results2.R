#' Split outcome column 
#'
#' This function takes the outcome column from the results generated by mr() and splits it into separate columns for 'outcome name' and 'id'
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame

split_outcome <- function(mr_res)
{
	Pos<-grep("\\|\\|",mr_res$outcome) #the "||"" indicates that the outcome column was derived from summary data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
	Outcome<-as.character(mr_res$outcome[Pos])
	Vars<-strsplit(Outcome,split= "\\|\\|")
	Vars<-unlist(Vars)
	Vars<-trim(Vars)
	Trait<-Vars[seq(1,length(Vars),by=2)]
	id<-Vars[seq(2,length(Vars),by=2)]
	mr_res$outcome<-as.character(mr_res$outcome)
	mr_res$outcome[Pos]<-Trait
	return(mr_res)
}

#' Split exposure column 
#'
#' This function takes the exposure column from the results generated by mr() and splits it into separate columns for 'exposure name' and 'id'
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame
split_exposure <- function(mr_res)
{
	Pos<-grep("\\|\\|",mr_res$exposure) #the "||"" indicates that the outcome column was derived from summary data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
	Exposure<-as.character(mr_res$exposure[Pos])
	Vars<-strsplit(as.character(Exposure),split= "\\|\\|")
	Vars<-unlist(Vars)
	Vars<-trim(Vars)
	Trait<-Vars[seq(1,length(Vars),by=2)]
	mr_res$exposure<-as.character(mr_res$exposure)
	mr_res$exposure[Pos]<-Trait
	return(mr_res)
}


#' Generate odds ratios 
#'
#' This function takes b and se from mr() and generates odds ratios and 95 percent confidence intervals
#'
#' @param mr_res Results from mr()
#'
#' @export
#' @return data frame		
generate_odds_ratios <- function(mr_res) 
{
	mr_res$lo_ci <- mr_res$b - 1.96 * mr_res$se
	mr_res$up_ci <- mr_res$b + 1.96 * mr_res$se
	mr_res$or <- exp(mr_res$b)
	mr_res$or_lci95 <- exp(mr_res$lo_ci)
	mr_res$or_uci95 <- exp(mr_res$up_ci)
	return(mr_res)
}

#' Subset MR-results on method
#'
#' This function takes MR results from mr() and restricts to a single method per exposure x disease combination 
#'
#' @param mr_res Results from mr()
#' @param single_snp_method Which of the single SNP methosd to use when only 1 SNP was used to estimate the causal effect? Default="Wald ratio"
#' @param multi_snp_method Which of the multi-SNP methods to use when there was more than 1 SNPs used to estimate the causal effect? Default="Inverse variance weighted"
#'
#' @export
#' @return data frame.
subset_on_method <- function(mr_res, single_snp_method="Wald ratio", multi_snp_method="Inverse variance weighted")
{
	dat <- subset(mr_res, (nsnp==1 & method==single_snp_method) | (nsnp > 1 & method == multi_snp_method))
	return(dat)

}

#' Combine all mr results
#'
#' This function combines results of mr(), mr_heterogeneity(), mr_pleiotropy() and mr_singlesnp() into a single data frame. It also merges the results with outcome study level characteristics in available_outcomes(). If desired it also exponentiates results (e.g. if the user wants log odds ratio converted into odds ratios with 95 percent confidence intervals)
#'
#' @param Res Results from mr()
#' @param Het Results from mr_heterogeneity()
#' @param Pleiotropy Results from mr_pleiotropy_test()
#' @param Res_single Results from mr_singlesnp()
#' @param ao_slc Logical; if set to TRUE then outcome study level characteristics are retrieved from available_outcomes(). Default is TRUE. 
#' @param Exp Logical; if set to TRUE results are exponentiated. Useful if user wants log odds ratios expressed as odds ratios. Default is FALSE. 
#' 
#' @export
#' @return data frame
combine_all_mrresults <- function(Res,Het,Pleiotropy,Res_single,ao_slc=T,Exp=F)
{
	requireNamespace("plyr", quietly=TRUE)

	Het<-Het[,c("id.outcome","method","Q","Q_df","Q_pval")]

	# Convert all factors to character
	# lapply(names(Res), FUN=function(x) class(Res[,x]))
	Pos<-which(unlist(lapply(names(Res), FUN=function(x) class(Res[,x])))=="factor")
	for(i in 1:length(Pos)){
		Res[,Pos[i]]<-as.character(Res[,Pos[i]])
	}

	# lapply(names(Het), FUN=function(x) class(Het[,x]))
	Pos<-which(unlist(lapply(names(Het), FUN=function(x) class(Het[,x])))=="factor")
	for(i in 1:length(Pos)){
		Het[,Pos[i]]<-as.character(Het[,Pos[i]])
	}

	# lapply(names(Res_single), FUN=function(x) class(Res_single[,x]))
	Pos<-which(unlist(lapply(names(Res_single), FUN=function(x) class(Res_single[,x])))=="factor")
	for(i in 1:length(Pos)){
		Res_single[,Pos[i]]<-as.character(Res_single[,Pos[i]])
	}
	Res_single<-Res_single[grep("[:0-9:]",Res_single$SNP),]
	Res_single$method<-"Wald ratio"
	names(Res_single)[names(Res_single)=="p"]<-"pval"

	# Res<-Res[Res$method %in% c("MR Egger","Weighted median","Inverse variance weighted"),]

	#method is also the name of an argument in the method function. this prevents all.x argument from working. rename method column
	names(Res)[names(Res)=="method"]<-"Method"
	names(Het)[names(Het)=="method"]<-"Method"
	names(Res_single)[names(Res_single)=="method"]<-"Method"

	Res<-merge(Res,Het,by=c("id.outcome","Method"),all.x=T)
	Res<-plyr::rbind.fill(Res,Res_single)

	if(ao_slc)
	{
		ao<-available_outcomes()
		names(ao)[names(ao)=="nsnp" ]<-"nsnps.outcome.array"
		Res<-merge(Res,ao[,!names(ao) %in% c("unit","priority","sd","path","note","filename","access","mr")],by.x="id.outcome",by.y="id")
	}

	Res$nsnp[is.na(Res$nsnp)]<-1

	for(i in unique(Res$id.outcome))
	{
		Methods<-unique(Res$method[Res$id.outcome==i])
		Methods<-Methods[Methods!="Wald ratio"]
		for(j in unique(Methods))
		{
			Res$snp[Res$id.outcome == i & Res$method==j]<-paste(Res$snp[Res$id.outcome == i & Res$method=="Wald ratio"],collapse="; ")
		}
	}

	if(Exp){
		Res$or<-exp(Res$b)
		Res$or_lci95<-exp(Res$b-Res$se*1.96)
		Res$or_uci95<-exp(Res$b+Res$se*1.96)
	}

	# add intercept test from MR Egger
	Pleiotropy<-Pleiotropy[,c("id.outcome","egger_intercept","se","pval")]
	Pleiotropy$Method<-"MR Egger"
	names(Pleiotropy)[names(Pleiotropy)=="egger_intercept"]<-"intercept"
	names(Pleiotropy)[names(Pleiotropy)=="se"]<-"intercept_se"
	names(Pleiotropy)[names(Pleiotropy)=="pval"]<-"intercept_pval"


	Res<-merge(Res,Pleiotropy,by=c("id.outcome","Method"),all.x=T)

	# names(ResSNP)<-tolower(names(ResSNP))
	return(Res)
}

#' Power prune 
#'
#' Where there are duplicate summary sets for a particular exposure-outcome combination, this function identifies the exposure-outcome summary set with highest a priori statistical power, taking into account the number of cases and controls and the variance in the exposure explained by the available SNPs. The duplicate summary sets with lower power are dropped by default. The function assumes that the SNP-outcome effects are log odds ratios. The function also assumes that the SNP-exposure effects are in standard deviation units. 
#'
#' @param dat Results from harmonise_data() 
#' @param drop.duplicates Should the duplicate exposure-outcome summary sets with lower power be dropped? Default set to TRUE 
#' 
#' @export
#' @return data frame

# library(TwoSampleMR)
# library(MRInstruments)

# exp_dat <- extract_instruments(outcomes=c(2,300))

# chd_out_dat <- extract_outcome_data(
#     snps = exp_dat$SNP,
#     outcomes = c(6,7,8,9)
# )

# dat <- harmonise_data(
#     exposure_dat = exp_dat, 
#     outcome_dat = chd_out_dat
# )

# dat2<-power.prune(dat,drop.duplicates=T)

power.prune <- function(dat,drop.duplicates=T)
{

	# dat[,c("eaf.exposure","beta.exposure","se.exposure","samplesize.outcome","ncase.outcome","ncontrol.outcome")]

	p<-dat$eaf.exposure #effect allele frequency
	b<-abs(dat$beta.exposure) # effect of SNP on risk factor
	se<-dat$se.exposure
	# n<-dat$samplesize.exposure
	n.cas<-dat$ncase.outcome
	n.con<-dat$ncontrol.outcome
	b1=log(1.05) # assumed log odds ratio
	sig<-0.05 #alpha

	var<-1 # variance of risk factor assumed to be 1 
	# if(!vareq1){ #if variance not 1 then estimate standardized beta using this syntax
	# 	z = b/se
	# 	b = z/sqrt(2*p*(1-p)*(n+z^2))
		
	# }

	r2<-2*b^2*p*(1-p)/var

	#Once the r2 is calculated you then sum the r2 statistics across all the SNPs in the instrument. 
	#This assumes each SNP is independent. 
	#calculate the F statistic for the instrument:
	id<-paste(dat$exposure,dat$outcome)
	Power<-NULL
	iv.se<-NULL
	ID<-NULL
	for(i in 1:length(unique(id))){
		print(unique(id)[i])
		pos<-which(id==unique(id)[i])
		# print(pos)
		k<-length(p[pos]) #number of SNPs in the instrument / associated with the risk factor
		# n<-min(n) #sample size of the exposure/risk factor GWAS
		r2sum<-sum(r2[pos]) # sum of the r-squares for each SNP in the instrument
		# F<-r2sum*(n-1-k)/((1-r2sum*k )
		n<-unique(n.con[pos]+n.cas[pos])
		ratio<-unique(n.con[pos]/n.cas[pos])
		iv.se[[i]]<-1/sqrt(unique(n.cas[pos])*unique(n.con[pos])*r2sum) #standard error of the IV should be proportional to this
		Power[[i]]<-pnorm(sqrt(n*r2sum*(ratio/(1+ratio))*(1/(1+ratio)))*b1-qnorm(1-sig/2))
		ID[[i]]<-unique(id)[i]
	}
	power.tab<-data.frame(as.matrix(cbind(ID,Power)),stringsAsFactors=F)
	dat$id.expout<-paste(dat$exposure,dat$outcome)
	dat<-merge(dat,power.tab,by.x="id.expout",by.y="ID")
	dat<-dat[order(dat$Power,decreasing=T),]
	# unique(dat[,c("originalname.outcome","Power")])
	if(drop.duplicates==T){
		id.keep<-dat$id.expout[!duplicated(paste(dat$exposure,dat$originalname.outcome))]
		dat<-dat[dat$id.expout %in% id.keep,]

	}
	return(dat)
}




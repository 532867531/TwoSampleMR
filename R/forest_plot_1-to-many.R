#' Format MR results for a 1-to-many forest plot
#'
#' This function formats user-supplied results for the forest_plot_1_to_many() function. The user supplies their results in the form of a data frame. The data frame is assumed to contain at least three columns of data: 1) effect estimates, from an analysis of the effect of an exposure on an outcome; 2) standard errors for the effect estimates; and 3) a column of trait names, corresponding to the 'many' in a 1-to-many forest plot.   
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param b Name of the column specifying the effect of the exposure on the outcome. Default = "b"
#' @param se Name of the column specifying the standard error for b. Default = "se"
#' @param TraitM The column specifying the names of the traits. Corresponds to 'many' in the 1-to-many forest plot. Default="outcome"
#' @param by Name of the column indicating a grouping variable to stratify results on. Default=NULL
#' @param Alt_name Name of the column specifying an alternative label for the Y axis. Typically the Y axis in a 1-to-many forest plot corresponds to a column of trait names. If, however, the user wishes to stratify the results by trait name, then an alternative column of data must be used to label the Y axis. For example, the user wishes to plot results for multiple exposures from observational and MR studies. In addition, the user wishes to group the observational and MR studies together for comparison. In this case something like a study column with vwould be used to specify Alt_name. Alt_name is only required if by=TraitM. Default = NULL. 
#' @param exponentiate Convert log odds ratios to odds ratios? Default=FALSE
#' @param ao_slc Logical; retrieve trait subcategory information using available_outcomes(). Default=FALSE
#'
#' @export
#' @return data frame.
format_1_to_many <- function(mr_res, b="b",se="se",exponentiate=FALSE, ao_slc=F,by=NULL,TraitM="outcome",Alt_name=NULL)
{

	requireNamespace("ggplot2", quietly=TRUE)
	requireNamespace("plyr", quietly=TRUE)

	if("exposure" %in% names(mr_res)){ #the plot function currently tries to plot separate plots for each unique exposure. This is a legacy of the original multiple exposures forest plot function and needs to be cleaned up. The function won't work if the TraitM column is called exposure
		names(mr_res)[names(mr_res)=="exposure"]<-"TraitM"
		TraitM<-"TraitM"
	}

	if(!is.null(by)){
		if(TraitM==by){
			if(is.null(Alt_name)) warning("Alt_name required because you are attempting to stratify results by ",TraitM)
			TraitM<-Alt_name
		}
	}

	if(!is.null(by)){
		names(mr_res)[names(mr_res)==by]<-"subcategory"
	}else{
		mr_res$subcategory<-""
	}

	names(mr_res)[names(mr_res)==b ]<-"b"
	names(mr_res)[names(mr_res)==se ]<-"se"
	Letters<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
	mr_res$outcome2<-mr_res[,TraitM]
	mr_res[,TraitM]<-paste(Letters[1:length(mr_res[,TraitM])],mr_res[,TraitM])

	mr_res$subcategory<-trim(mr_res$subcategory)
	mr_res$exposure<-""

	# Get extra info on outcomes
	if(ao_slc) 
	{ 
		ao <- available_outcomes()
		ao$subcategory[ao$subcategory == "Cardiovascular"] <- "Cardiometabolic"
		ao$subcategory[ao$trait == "Type 2 diabetes"] <- "Cardiometabolic"
		names(ao)[names(ao) == "nsnp"]<-"nsnp.array"
	}

	dat<-mr_res
	dat$index <- 1:nrow(dat)
	
	if(ao_slc)
	{ 
		dat <- merge(dat, ao, by.x="id.outcome", by.y="id")
	}
	dat <- dat[order(dat$b), ]

	# Create CIs
	dat$up_ci <- as.numeric(dat$b) + 1.96 * as.numeric(dat$se)
	dat$lo_ci <- as.numeric(dat$b) - 1.96 * as.numeric(dat$se)

	# Exponentiate?
	if(exponentiate)
	{
		dat$b <- exp(as.numeric(dat$b))
		dat$up_ci <- exp(dat$up_ci)
		dat$lo_ci <- exp(dat$lo_ci)
	}
	
	# Organise cats
	dat$subcategory <- as.factor(dat$subcategory)
	
	if(!ao_slc) #generate a simple trait column. this contains only the outcome name (ie excludes consortium and year from the outcome column generated by mr()). This step caters to the possibility that a user's results contain a mixture of results obtained via MR-Base and correspondence. The later won't be present in the MR-Base database. However, still need to split the outcome name into trait, year and consortium. 
	{

		dat$trait<-as.character(dat[,TraitM])
		Pos<-grep("\\|\\|",dat$trait) #this indicates the outcome column was derived from data in MR-Base. Sometimes it wont look like this e.g. if the user has supplied their own outcomes
		if(sum(Pos)!=0)
		{
			Outcome<-dat$trait[Pos]
			Outcome<-unlist(strsplit(Outcome,split="\\|\\|"))
			Outcome<-Outcome[seq(1,length(Outcome),by=2)]
			Outcome<-trim(Outcome)
			dat$trait[Pos]<-Outcome
		}

	}


	dat <- data.frame(
		exposure = as.character(dat$exposure),
		outcome = as.character(dat$trait),
		outcome2= as.character(dat$outcome2),
		# ncase=as.numeric(dat$ncase),
		category = as.character(dat$subcategory),
		effect = dat$b,
		up_ci = dat$up_ci,
		lo_ci = dat$lo_ci,
		nsnp = dat$nsnp,
		# pval = dat$pval,
		# sample_size = dat$sample_size,
		index = dat$index,
		stringsAsFactors = FALSE
	)
	
	exps <- unique(dat$exposure)
	
	dat <- dat[order(dat$index), ]

	dat <- dat[order(dat$outcome), ]

	return(dat)
}

#' Sort results for 1-to-many forest plot
#'
#' This function sorts user-supplied results for the forest_plot_1_to_many() function. The user supplies their results in the form of a data frame.    
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param Group Name of grouping variable in mr_res. 
#' @param Priority Choose which value of the grouping variable defined by Group should be given priority and go to the top of the plot. 
#' @param Sort.action Choose how to sort results. 1 =sort results by effect size within groups. Use the group order supplied by the user. 2=sort results by effect size and group. Overides the group ordering supplied by the user. 3=group results for the same trait together (e.g. multiple results for the same trait from observational and Mendelian randomization studies or from different MR methods). 4= sort by decreasing effect size (largest effect size at top and smallest at bottom). 5= sort by increasing effect size (smallest effect size at top and largest at bottom) 
#'
#' @export
#' @return data frame.
# 
# Trait.var="exposure",Sort.var1="subcategory",Sort.var2="b",Sort1.decreasing = F,Sort2.decreasing=F,
Sort.1.to.many<-function(mr_res,b="b",Sort.action=4,Group=NULL,Priority=NULL){

	if(!b %in% names(mr_res)) warning("Column with effect estimates not found. Did you forget to specify the column of data containing your effect estimates?")
	if(Sort.action==1){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		
		# Numbers<-1:100
		Letters<-c("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z")
		Groups<-unique(mr_res[,Group])
		mr_res$Index<-unlist(lapply(1:length(unique(mr_res[,Group])),FUN=function(x) rep(Letters[Letters==Letters[x]],length(which(mr_res[,Group]==Groups[x])))))
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
		mr_res$Index2<-Letters[1:nrow(mr_res)]
		mr_res$Index3<-paste(mr_res$Index,mr_res$Index2,sep="")
		mr_res<-mr_res[order(mr_res$Index3),]
		mr_res<-mr_res[,!names(mr_res) %in% c("Index","Index2","Index3")]
	}

	if(Sort.action ==2){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
		mr_res<-mr_res[order(mr_res[,Group]),]
	}
		
		# mr_res2$Index<-Letters[1:nrow(mr_res2)]
		# Index<-Index[order(mr_res2$b,decreasing=T)]
	
	if(Sort.action==3){
		if(is.null(Group)) warning("You must indicate a grouping variable")
		if(is.null(Priority)) warning("You must indicate which value of the grouping variable ",Group," to use as the priority value")
		mr_res$b.sort<-NA
		mr_res$b.sort[mr_res[,Group]==Priority]<-mr_res[,b][mr_res[,Group]==Priority]
		mr_res$b.sort[is.na(mr_res$b.sort)]<-mr_res$b.sort[!is.na(mr_res$b.sort)]
		mr_res<-mr_res[order(mr_res[,Group]),]
		mr_res<-mr_res[order(mr_res$b.sort,decreasing=T),]
	}

	if(Sort.action ==4){
		mr_res<-mr_res[order(mr_res[,b],decreasing=T),]
	}

	if(Sort.action ==5){
		mr_res<-mr_res[order(mr_res[,b],decreasing=F),]
	}

	# mr_res<-mr_res[order(mr_res[,Sort.var2],decreasing=Sort2.decreasing),]
	# id<-paste(mr_res[,Sort.var1],mr_res[,Trait.var])
	# mr_res<-mr_res[order(id,decreasing=T),]

	
	# Letters1<-unlist(lapply(1:length(Letters),FUN=function(x) rep(Letters[x],26)))
	# Letters0<-paste(Letters1,Letters,sep="")
	# Letters0<-Letters0[1:length(mr_res[,Sort.var2])]

	# mr_res$outcome<-paste(Letters0, mr_res$exposure,sep="")

	# mr_res<-mr_res[order(Letters0),]
	return(mr_res)
	
}


# #' Simple attempt at correcting string case
# #'
# #' @param x Character or array of character
# #'
# #' @return Character or array of character
# simple_cap <- function(x) {
# 	sapply(x, function(x){
# 		x <- tolower(x)
# 		s <- strsplit(x, " ")[[1]]
# 		paste(toupper(substring(s, 1,1)), substring(s, 2), sep="", collapse=" ")
# 	})
# }

#' Trim function 
#'
#' Trim function to remove leading and trailing blank spaces
#'
# #' @param x Character or array of character
# #'
# #' @export
# #' @return Character or array of character
# trim <- function( x ) {
#   gsub("(^[[:space:]]+|[[:space:]]+$)", "", x)
# }


# #' Create fixed width label
# #'
# #' @param n1 number
# #' @param nom name
# #'
# #' @return text
# create_label <- function(n1, nom)
# {
# 	len_n1 <- max(nchar(n1), na.rm=TRUE)
# 	n1_c <- formatC(n1, width=len_n1)

# 	l <- nchar(nom)
# 	len_nom <- max(l)
# 	p <- paste0("%-", len_nom, "s")
# 	nomp <- sprintf(p, nom)

# 	out <- paste0(n1_c, "    ", nomp)
# 	out <- factor(out, levels = unique(out))
# 	return(out)
# }

#' A basic forest plot
#'
#' This function is used to create a basic forest plot.
#' It requires the output from format_1_to_many().
#'
#' @param dat Output from format_1_to_many()
#' @param section Which category in dat to plot. If NULL then prints everything
#' @param colour_group Which exposure to plot. If NULL then prints everything grouping by colour.
#' @param xlab x-axis label. Default=NULL
#' @param bottom Show x-axis? Default=FALSE
#' @param trans x-axis scale
#' @param xlim x-axis limits
#' @param Lo Lower limit of x axis 
#' @param Up Upper limit of x axis 
#'
#' @return ggplot object
forest_plot_basic2 <- function(dat, section=NULL, colour_group=NULL, colour_group_first=TRUE, xlab=NULL, bottom=TRUE, trans="identity", xlim=NULL, Lo=Lo,Up=Up)
{
	if(bottom)
	{
		text_colour <- ggplot2::element_text(colour="black")
		tick_colour <- ggplot2::element_line(colour="black")
		xlabname <- xlab
	} else {
		text_colour <- ggplot2::element_blank()
		tick_colour <- ggplot2::element_blank()
		xlabname <- NULL
	}

	# OR or log(OR)?
	# If CI are symmetric then log(OR)
	# Use this to guess where to put the null line
	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

	# Change lab
	if(!is.null(xlim))
	{
		stopifnot(length(xlim) == 2)
		stopifnot(xlim[1] < xlim[2])
		dat$lo_ci <- pmax(dat$lo_ci, xlim[1], na.rm=TRUE)
		dat$up_ci <- pmin(dat$up_ci, xlim[2], na.rm=TRUE)
	}

	up <- max(dat$up_ci, na.rm=TRUE)
	lo <- min(dat$lo_ci, na.rm=TRUE)
	r <- up-lo
	lo_orig <- lo
	lo <- lo - r * 0.5

	if(!is.null(section))
	{
		dat <- subset(dat, category==section)
		main_title <- section
	} else {
		main_title <- ""
	}

	if(!is.null(colour_group))
	{
		dat <- subset(dat, exposure == colour_group)
		point_plot <- ggplot2::geom_point(size=2)
	} else {
		point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)
	}

	if((!is.null(colour_group) & colour_group_first) | is.null(colour_group))
	{
		outcome_labels <- ggplot2::geom_text(ggplot2::aes(label=outcome2,colour="red"), x=lo, y=mean(c(1, length(unique(dat$exposure)))), hjust=0, vjust=0.5, size=2.5)
		main_title <- ifelse(is.null(section), "", section)
		title_colour <- "black"

	# ncases_labels <- ggplot2::geom_text(
	# 	ggplot2::aes(label=ncase), 
	# 	x=lo, 
	# 	y=mean(c(1, length(unique(dat$exposure)))), 
	# 	hjust=0, vjust=0.5, size=3.5
	# )

	} else {
		outcome_labels <- NULL
		lo <- lo_orig
		main_title <- ""
		title_colour <- "white"
	}

	main_title <- section

	# if(! "lab" %in% names(dat))
	# {
	# 	dat$lab <- create_label(dat$sample_size, dat$outcome2)
	# }

	dat$lab<-dat$outcome
	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
	l$col[1:nrow(l) %% 2 == 0] <- "b"

	dat <- merge(dat, l, by="lab", all.x=TRUE)
	dat <- dat[nrow(dat):1, ]

	lo<-Lo
	up<-Up
	p <-ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
	ggplot2::geom_vline(xintercept=seq(ceiling(lo_orig), ceiling(up), by=0.5), colour="white", size=0.3) +
	ggplot2::geom_vline(xintercept=null_line, colour="#333333", size=0.3) +
	ggplot2::geom_errorbarh(ggplot2::aes(xmin=lo_ci, xmax=up_ci), height=0, size=0.4, colour="#aaaaaa") +
	ggplot2::geom_point(colour="black", size=2.2) +
	point_plot +
	ggplot2::facet_grid(lab ~ .) +
	ggplot2::scale_x_continuous(trans=trans, limits=c(lo, up)) +
	ggplot2::scale_colour_brewer(type="qual") +
	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
	ggplot2::theme(
		axis.line=ggplot2::element_blank(),
		axis.text.y=ggplot2::element_blank(), 
		axis.ticks.y=ggplot2::element_blank(), 
		axis.text.x=text_colour, 
		axis.ticks.x=tick_colour, 
		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
		strip.background=ggplot2::element_rect(fill="white", colour="white"),
		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=9),
		legend.position="none",
		legend.direction="vertical",
		panel.grid.minor.x=ggplot2::element_blank(),
		panel.grid.minor.y=ggplot2::element_blank(),
		panel.grid.major.y=ggplot2::element_blank(),
		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=title_colour),
		plot.margin=ggplot2::unit(c(2,3,2,0), units="points"),
		plot.background=ggplot2::element_rect(fill="white"),
		panel.spacing=ggplot2::unit(0,"lines"),
		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
		strip.text.y = ggplot2::element_blank()
		# strip.background = ggplot2::element_blank()
	) +
	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title=main_title) +
	outcome_labels
	return(p)
}


forest_plot_names2 <- function(dat, section=NULL, var1="outcome2",bottom=TRUE)
{
	if(bottom)
	{
		text_colour <- ggplot2::element_text(colour="white")
		tick_colour <- ggplot2::element_line(colour="white")
		xlabname <- ""
	} else {
		text_colour <- ggplot2::element_blank()
		tick_colour <- ggplot2::element_blank()
		xlabname <- NULL
	}

	# OR or log(OR)?
	# If CI are symmetric then log(OR)
	# Use this to guess where to put the null line
	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

	# up <- max(dat$up_ci, na.rm=TRUE)
	# lo <- min(dat$lo_ci, na.rm=TRUE)
	# r <- up-lo
	# lo_orig <- lo
	# lo <- lo - r * 0.5
	lo <- 0
	up <- 1

	if(!is.null(section))
	{
		dat <- subset(dat, category==section)
		main_title <- section
		section_colour <- "black"
	} else {
		main_title <- section
		section_colour <- "white"
	}

	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

	outcome_labels <- ggplot2::geom_text(
		ggplot2::aes(label=eval(parse(text=var1))), 
		x=lo, 
		y=mean(c(1, length(unique(dat$exposure)))), 
		hjust=0, vjust=0.5, size=3.5
	)





	# ncases_labels <- ggplot2::geom_text(
	# 	ggplot2::aes(label=ncase), 
	# 	x=lo, 
	# 	y=mean(c(1, length(unique(dat$exposure)))), 
	# 	hjust=0, vjust=0.5, size=3.5
	# )

	main_title <- section

	# if(! "lab" %in% names(dat))
	# {
	# 	dat$lab <- create_label(dat$sample_size, dat$outcome2)
	# }

	dat$lab<-dat$outcome
	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
	l$col[1:nrow(l) %% 2 == 0] <- "b"

	dat <- merge(dat, l, by="lab", all.x=TRUE)

	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
	ggplot2::facet_grid(lab ~ .) +
	ggplot2::scale_x_continuous(limits=c(lo, up)) +
	ggplot2::scale_colour_brewer(type="qual") +
	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
	ggplot2::theme(
		axis.line=ggplot2::element_blank(),
		axis.text.y=ggplot2::element_blank(), 
		axis.ticks.y=ggplot2::element_blank(), 
		axis.text.x=text_colour, 
		axis.ticks.x=tick_colour, 
		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
		strip.background=ggplot2::element_rect(fill="white", colour="white"),
		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
		legend.position="none",
		legend.direction="vertical",
		panel.grid.minor.x=ggplot2::element_blank(),
		panel.grid.minor.y=ggplot2::element_blank(),
		panel.grid.major.y=ggplot2::element_blank(),
		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
		plot.background=ggplot2::element_rect(fill="white"),
		panel.spacing=ggplot2::unit(0,"lines"),
		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
		strip.text.y = ggplot2::element_blank()
		# strip.background = ggplot2::element_blank()
	) +
	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title=main_title) +
	outcome_labels
	return(p)
}


# forest_plot_var2 <- function(dat, section=NULL, var2=var2,bottom=TRUE)
# {
# 	if(bottom)
# 	{
# 		text_colour <- ggplot2::element_text(colour="white")
# 		tick_colour <- ggplot2::element_line(colour="white")
# 		xlabname <- ""
# 	} else {
# 		text_colour <- ggplot2::element_blank()
# 		tick_colour <- ggplot2::element_blank()
# 		xlabname <- NULL
# 	}

# 	# OR or log(OR)?
# 	# If CI are symmetric then log(OR)
# 	# Use this to guess where to put the null line
# 	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

# 	# up <- max(dat$up_ci, na.rm=TRUE)
# 	# lo <- min(dat$lo_ci, na.rm=TRUE)
# 	# r <- up-lo
# 	# lo_orig <- lo
# 	# lo <- lo - r * 0.5
# 	lo <- 0
# 	up <- 1

# 	if(!is.null(section))
# 	{
# 		dat <- subset(dat, category==section)
# 		main_title <- section
# 		section_colour <- "black"
# 	} else {
# 		main_title <- section
# 		section_colour <- "white"
# 	}

# 	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

# 	outcome_labels <- ggplot2::geom_text(
# 		ggplot2::aes(label=eval(parse(text=var2))), 
# 		x=lo, 
# 		y=mean(c(1, length(unique(dat$exposure)))), 
# 		hjust=0, vjust=0.5, size=3.5
# 	)

# 	# ncases_labels <- ggplot2::geom_text(
# 	# 	ggplot2::aes(label=ncase), 
# 	# 	x=lo, 
# 	# 	y=mean(c(1, length(unique(dat$exposure)))), 
# 	# 	hjust=0, vjust=0.5, size=3.5
# 	# )

# 	main_title <- section

# 	# if(! "lab" %in% names(dat))
# 	# {
# 	# 	dat$lab <- create_label(dat$sample_size, dat$outcome2)
# 	# }

# 	dat$lab<-dat$outcome
# 	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
# 	l$col[1:nrow(l) %% 2 == 0] <- "b"

# 	dat <- merge(dat, l, by="lab", all.x=TRUE)

# 	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
# 	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
# 	ggplot2::facet_grid(lab ~ .) +
# 	ggplot2::scale_x_continuous(limits=c(lo, up)) +
# 	ggplot2::scale_colour_brewer(type="qual") +
# 	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
# 	ggplot2::theme(
# 		axis.line=ggplot2::element_blank(),
# 		axis.text.y=ggplot2::element_blank(), 
# 		axis.ticks.y=ggplot2::element_blank(), 
# 		axis.text.x=text_colour, 
# 		axis.ticks.x=tick_colour, 
# 		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
# 		strip.background=ggplot2::element_rect(fill="white", colour="white"),
# 		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
# 		legend.position="none",
# 		legend.direction="vertical",
# 		panel.grid.minor.x=ggplot2::element_blank(),
# 		panel.grid.minor.y=ggplot2::element_blank(),
# 		panel.grid.major.y=ggplot2::element_blank(),
# 		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
# 		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
# 		plot.background=ggplot2::element_rect(fill="white"),
# 		panel.spacing=ggplot2::unit(0,"lines"),
# 		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
# 		strip.text.y = ggplot2::element_blank(),
# 		strip.text.x = ggplot2::element_blank()
# 		# strip.background = ggplot2::element_blank()
# 	) +
# 	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title="") +
# 	outcome_labels
# 	return(p)
# }


# forest_plot_var3 <- function(dat, section=NULL, var3=var3,bottom=TRUE)
# {
# 	if(bottom)
# 	{
# 		text_colour <- ggplot2::element_text(colour="white")
# 		tick_colour <- ggplot2::element_line(colour="white")
# 		xlabname <- ""
# 	} else {
# 		text_colour <- ggplot2::element_blank()
# 		tick_colour <- ggplot2::element_blank()
# 		xlabname <- NULL
# 	}

# 	# OR or log(OR)?
# 	# If CI are symmetric then log(OR)
# 	# Use this to guess where to put the null line
# 	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

# 	# up <- max(dat$up_ci, na.rm=TRUE)
# 	# lo <- min(dat$lo_ci, na.rm=TRUE)
# 	# r <- up-lo
# 	# lo_orig <- lo
# 	# lo <- lo - r * 0.5
# 	lo <- 0
# 	up <- 1

# 	if(!is.null(section))
# 	{
# 		dat <- subset(dat, category==section)
# 		main_title <- section
# 		section_colour <- "black"
# 	} else {
# 		main_title <- section
# 		section_colour <- "white"
# 	}

# 	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

# 	outcome_labels <- ggplot2::geom_text(
# 		ggplot2::aes(label=eval(parse(text=var3))), 
# 		x=lo, 
# 		y=mean(c(1, length(unique(dat$exposure)))), 
# 		hjust=0, vjust=0.5, size=3.5
# 	)



# 	# ncases_labels <- ggplot2::geom_text(
# 	# 	ggplot2::aes(label=tv), 
# 	# 	x=lo, 
# 	# 	y=mean(c(1, length(unique(dat$exposure)))), 
# 	# 	hjust=0, vjust=0.5, size=3.5
# 	# )

# 	main_title <- section

# 	# if(! "lab" %in% names(dat))
# 	# {
# 	# 	dat$lab <- create_label(dat$sample_size, dat$outcome2)
# 	# }

# 	dat$lab<-dat$outcome
# 	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
# 	l$col[1:nrow(l) %% 2 == 0] <- "b"

# 	dat <- merge(dat, l, by="lab", all.x=TRUE)

# 	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
# 	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
# 	ggplot2::facet_grid(lab ~ .) +
# 	ggplot2::scale_x_continuous(limits=c(lo, up)) +
# 	ggplot2::scale_colour_brewer(type="qual") +
# 	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
# 	ggplot2::theme(
# 		axis.line=ggplot2::element_blank(),
# 		axis.text.y=ggplot2::element_blank(), 
# 		axis.ticks.y=ggplot2::element_blank(), 
# 		axis.text.x=text_colour, 
# 		axis.ticks.x=tick_colour, 
# 		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
# 		strip.background=ggplot2::element_rect(fill="white", colour="white"),
# 		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
# 		legend.position="none",
# 		legend.direction="vertical",
# 		panel.grid.minor.x=ggplot2::element_blank(),
# 		panel.grid.minor.y=ggplot2::element_blank(),
# 		panel.grid.major.y=ggplot2::element_blank(),
# 		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
# 		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
# 		plot.background=ggplot2::element_rect(fill="white"),
# 		panel.spacing=ggplot2::unit(0,"lines"),
# 		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
# 		strip.text.y = ggplot2::element_blank(),
# 		strip.text.x = ggplot2::element_blank()
# 		# strip.background = ggplot2::element_blank()
# 	) +
# 	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title="") +
# 	outcome_labels
# 	return(p)
# }

# forest_plot_var4 <- function(dat, section=NULL,var4=var4, bottom=TRUE)
# {
# 	if(bottom)
# 	{
# 		text_colour <- ggplot2::element_text(colour="white")
# 		tick_colour <- ggplot2::element_line(colour="white")
# 		xlabname <- ""
# 	} else {
# 		text_colour <- ggplot2::element_blank()
# 		tick_colour <- ggplot2::element_blank()
# 		xlabname <- NULL
# 	}

# 	# OR or log(OR)?
# 	# If CI are symmetric then log(OR)
# 	# Use this to guess where to put the null line
# 	null_line <- ifelse(all.equal(dat$effect - dat$lo_ci, dat$up_ci - dat$effect) == TRUE, 0, 1)

# 	# up <- max(dat$up_ci, na.rm=TRUE)
# 	# lo <- min(dat$lo_ci, na.rm=TRUE)
# 	# r <- up-lo
# 	# lo_orig <- lo
# 	# lo <- lo - r * 0.5
# 	lo <- 0
# 	up <- 1

# 	if(!is.null(section))
# 	{
# 		dat <- subset(dat, category==section)
# 		main_title <- section
# 		section_colour <- "black"
# 	} else {
# 		main_title <- section
# 		section_colour <- "white"
# 	}

# 	point_plot <- ggplot2::geom_point(ggplot2::aes(colour=exposure), size=2)

# 	outcome_labels <- ggplot2::geom_text(
# 		ggplot2::aes(label=eval(parse(text=var4))), 
# 		x=lo, 
# 		y=mean(c(1, length(unique(dat$exposure)))), 
# 		hjust=0, vjust=0.5, size=3.5
# 	)

# 	# ncases_labels <- ggplot2::geom_text(
# 	# 	ggplot2::aes(label=tv), 
# 	# 	x=lo, 
# 	# 	y=mean(c(1, length(unique(dat$exposure)))), 
# 	# 	hjust=0, vjust=0.5, size=3.5
# 	# )

# 	main_title <- section

# 	# if(! "lab" %in% names(dat))
# 	# {
# 	# 	dat$lab <- create_label(dat$sample_size, dat$outcome2)
# 	# }

# 	dat$lab<-dat$outcome
# 	l <- data.frame(lab=sort(unique(dat$lab)), col="a", stringsAsFactors=FALSE)
# 	l$col[1:nrow(l) %% 2 == 0] <- "b"

# 	dat <- merge(dat, l, by="lab", all.x=TRUE)

# 	p <- ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=exposure)) +
# 	ggplot2::geom_rect(ggplot2::aes(fill=col), xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf) +
# 	ggplot2::facet_grid(lab ~ .) +
# 	ggplot2::scale_x_continuous(limits=c(lo, up)) +
# 	ggplot2::scale_colour_brewer(type="qual") +
# 	ggplot2::scale_fill_manual(values=c("#eeeeee", "#ffffff"), guide=FALSE) +
# 	ggplot2::theme(
# 		axis.line=ggplot2::element_blank(),
# 		axis.text.y=ggplot2::element_blank(), 
# 		axis.ticks.y=ggplot2::element_blank(), 
# 		axis.text.x=text_colour, 
# 		axis.ticks.x=tick_colour, 
# 		# strip.text.y=ggplot2::element_text(angle=360, hjust=0), 
# 		strip.background=ggplot2::element_rect(fill="white", colour="white"),
# 		strip.text=ggplot2::element_text(family="Courier New", face="bold", size=11),
# 		legend.position="none",
# 		legend.direction="vertical",
# 		panel.grid.minor.x=ggplot2::element_blank(),
# 		panel.grid.minor.y=ggplot2::element_blank(),
# 		panel.grid.major.y=ggplot2::element_blank(),
# 		plot.title = ggplot2::element_text(hjust = 0, size=12, colour=section_colour),
# 		plot.margin=ggplot2::unit(c(2,0,2,0), units="points"),
# 		plot.background=ggplot2::element_rect(fill="white"),
# 		panel.spacing=ggplot2::unit(0,"lines"),
# 		panel.background=ggplot2::element_rect(colour="red", fill="grey", size=1),
# 		strip.text.y = ggplot2::element_blank(),
# 		strip.text.x = ggplot2::element_blank()
# 		# strip.background = ggplot2::element_blank()
# 	) +
# 	ggplot2::labs(y=NULL, x=xlabname, colour="", fill=NULL, title="") +
# 	outcome_labels
# 	return(p)
# }

#' 1-to-many forest plot 
#'
#' Plot results from an analysis of multiple exposures against a single outcome or a single exposure against multiple outcomes. Plots effect estimates and 95 percent confidence intervals. The ordering of results in the plot is determined by the order supplied by the user.  Users may find Sort.1.to.many() helpful for sorting their results prior to using the 1-to-many forest plot. 
#' 
#' @param mr_res Data frame of results supplied by the user
#' @param b Name of the column specifying the effect of the exposure on the outcome. Default = "b"
#' @param se Name of the column specifying the standard error for b. Default = "se"
#' @param TraitM The column specifying the names of the traits. Corresponds to 'many' in the 1-to-many forest plot. Default="outcome"
#' @param by Name of the column indicating a grouping variable to stratify results on. Default=NULL
#' @param Alt_name Name of the column specifying an alternative label for the Y axis. Typically the Y axis in a 1-to-many forest plot corresponds to a column of trait names. If, however, the user wishes to stratify the results by trait name, then an alternative column of data must be used to label the Y axis. For example, the user wishes to plot results for multiple exposures from observational and MR studies. In addition, the user wishes to group the observational and MR studies together for comparison. In this case something like a study column with vwould be used to specify Alt_name. Alt_name is only required if by=TraitM. Default = NULL. 
#' @param exponentiate Convert log odds ratios to odds ratios? Default=FALSE
#' @param ao_slc Logical; retrieve trait subcategory information using available_outcomes(). Default=FALSE
#' @param trans Specify x-axis scale. e.g. "identity", "log2", etc. Default is "identity". If set to "identity" an additive scale is used. If set to log2 the x-axis is plotted on a multiplicative / doubling scale (preferable when plotting odds ratios and their confidence intervals). 
#' @param Lo Lower limit of X axis to plot. Must be specified by the user. 
#' @param Up Upper limit of X axis to plot. Must be specified by the user. 
#' @param Width1 Width of Y axis labels. Default=1
#'
#' @export
#' @return grid plot object
forest_plot_1_to_many <- function(mr_res, b="b",se="se",exponentiate=FALSE, trans="identity",ao_slc=T,Lo=NULL,Up=NULL,width1=1,by=NULL,TraitM="outcome",Alt_name=NULL){
	requireNamespace("ggplot2", quietly=TRUE)
	requireNamespace("cowplot", quietly=TRUE)
	requireNamespace("gridExtra", quietly=TRUE)
	
	if(is.null(Lo) | is.null(Up)) warning("Values missing for the lower or upper bounds of the x axis. Did you forget to set the Lo and Up arguments?")

	xlab=""
	xlim=NULL
	ncols=1
	# var2="";var3="";var4=""
	# width2=1,width3=1,width4=1

	# L<-nrow(mr_res)+length(unique(mr_res[,by]))
	# if(L >50 ){
	# 	warning("You have submitted more rows of data for plotting than is recommended. Try plotting fewer rows or set Force=TRUE to plot anyway.")
	# }


	dat <- format_1_to_many(
		mr_res, 
		b=b,
		se=se,
		exponentiate=exponentiate, 
		# single_snp_method=single_snp_method,
		# multi_snp_method=multi_snp_method,
		ao_slc=ao_slc,
		by=by,
		TraitM=TraitM,
		Alt_name=Alt_name
	)
	

	# dat$lab <- create_label(dat$sample_size, dat$outcome2)
	# dat$lab<-dat$outcome2

	legend <- cowplot::get_legend(
		ggplot2::ggplot(dat, ggplot2::aes(x=effect, y=outcome)) + 
		ggplot2::geom_point(ggplot2::aes(colour=exposure)) + 
		ggplot2::scale_colour_brewer(type="qual") + 
		ggplot2::labs(colour="Exposure") + 
		ggplot2::theme(text=ggplot2::element_text(size=10))
	)

	message("howzit, may all your scripts be up-to-date and well annotated")
	sec <- unique(as.character(dat$category))
	columns <- unique(dat$exposure)
	l <- list()
	h <- rep(0, length(sec))
	count <- 1
	for(i in 1:length(sec))
	{
		h[i] <- length(unique(subset(dat, category==sec[i])$outcome))
		l[[count]] <- forest_plot_names2(
			dat, 
			sec[i],
			bottom = i==length(sec)
		)
		count <- count + 1

		# if(var2!=""){
		# 	l[[count]] <- forest_plot_var2(
		# 		dat, 
		# 		sec[i], 
		# 		var2,
		# 		bottom = i==length(sec)
		# 	)
		# 	count <- count + 1
		# }
		# duplicate the above from l[[count]] with the new function (instead of forest_plot_ncase)
		# create forest_plot_newvalue
		# if(var3 != "") {
		# 	l[[count]] <- forest_plot_var3(
		# 		dat, 
		# 		sec[i], 
		# 		var3,
		# 		bottom = i==length(sec)
		# 	)
		# 	count <- count + 1
		# }
		# if(var4 != "") {
		# 	l[[count]] <- forest_plot_var4(
		# 		dat, 
		# 		sec[i], 
		# 		var4,
		# 		bottom = i==length(sec)
		# 	)
		# 	count <- count + 1
		# }
		for(j in 1:length(columns))
		{
			l[[count]] <- forest_plot_basic2(
				dat, 
				sec[i], 
				bottom = i==length(sec), 
				colour_group=columns[j], 
				colour_group_first = FALSE, 
				xlab = paste0(xlab, " ", columns[j]), 
				Lo=Lo,
				Up=Up,
				trans = trans,
				xlim = xlim
			)
			count <- count + 1
		}
	}
	h <- h + 1
	h[length(sec)] <- h[length(sec)] + 1
	message(length(l))
	message(count)
	message(h)
	return(
		cowplot::plot_grid(
			gridExtra::arrangeGrob(
				grobs=l, 
				# change this to 3
				ncol=length(columns) + ncols, 
				nrow=length(h), 
				heights=h,
				# add an extra width value
				widths=c(width1, rep(5, length(columns)))
				
			)
		)
	)

}

